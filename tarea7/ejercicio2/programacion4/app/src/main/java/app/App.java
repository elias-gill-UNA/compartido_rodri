/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package app;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

// Una clase para almacenar un borde de grafo
class Edge {
    int source, dest;

    public Edge(int source, int dest) {
        this.source = source;
        this.dest = dest;
    }
}

// Una clase para representar un objeto grafo
class grafo {
    // Una lista de listas para representar una lista de adyacencia
    List<List<Integer>> adjList = null;

    // Número total de nodos en el grafo
    int n;

    // Constructor
    grafo(List<Edge> edges, int n) {
        this.adjList = new ArrayList<>();
        this.n = n;

        for (int i = 0; i < n; i++) {
            adjList.add(new ArrayList<>());
        }

        // agrega bordes al grafo no dirigido
        for (Edge edge : edges) {
            int src = edge.source;
            int dest = edge.dest;

            adjList.get(src).add(dest);
            adjList.get(dest).add(src);
        }
        System.out.println(adjList);
    }
}

class App {
    // Realiza DFS en el grafo a partir del vértice `v`
    private static boolean DFS(grafo grafo, int v, boolean[] discovered,
            boolean[] color) {
        // hacer para cada borde (v, u)
        for (int u : grafo.adjList.get(v)) {
            // si se explora el vértice `u` por primera vez
            if (discovered[u] == false) {
                // marca el nodo actual como descubierto
                discovered[u] = true;
                // el nodo actual tiene el color opuesto al de su padre
                color[u] = !color[v];

                // si DFS en cualquier subárbol enraizado en `v` devuelve falso
                if (DFS(grafo, u, discovered, color) == false) {
                    return false;
                }
            }
            // si el vértice ya ha sido descubierto y
            // el color del vértice `u` y `v` son iguales, entonces
            // el grafo no es bipartito
            else if (color[v] == color[u]) {
                return false;
            }
        }

        // si es bipartito determina si es completo
        return true;
    }

    // clase de retorno de la funcion isBipartito()
    private class res {
        boolean[] color;
        boolean respuesta;

        public res(boolean r, boolean n[]) {
            color = n;
            respuesta = r;
        }
    }

    // Función para verificar si un grafo es bipartito usando DFS
    // retorna una clase res, la cual contiene un array con que contiene los nodos
    // de cada lado del grafo
    private res isBipartito(grafo grafo) {
        int n = grafo.n;

        // para realizar un seguimiento de si se descubre un vértice o no
        boolean[] discovered = new boolean[n];

        // realizar un seguimiento del color asignado (0 o 1) a cada vértice en DFS
        boolean[] color = new boolean[n];

        // comienza desde cualquier nodo ya que el grafo es conectado y no dirigido
        int src = 0;

        // marca el vértice de origen como descubierto y establece su color en 0
        discovered[src] = true;
        color[src] = false;

        // llamar al procedimiento DFS
        if (DFS(grafo, src, discovered, color)) {
            return new res(true, color);
        }
        return new res(false, new boolean[0]);
    }

    // funcion que determina si un grafo es compleot o no
    private static boolean esCompleto(grafo grafo, boolean color[]) {
        ArrayList<Integer> v1 = new ArrayList<>();
        ArrayList<Integer> v2 = new ArrayList<>();

        // cargar los subgrafos v1 y v2
        for (int i = 0; i < color.length; i++) {
            // cargar en v1
            if (color[i] == true) {
                v1.add(i);
            } else { // cargar en v2
                v2.add(i);
            }
        }

        // inicializar matriz de adyacencia
        int adyacencia[][] = new int[grafo.n][grafo.n];
        for (int i = 0; i < grafo.n; i++) {
            for (int k = 0; k < grafo.n; k++) {
                adyacencia[i][k] = 0;
            }
        }

        // cargar matriz de adyacencia
        for (int i = 0; i < grafo.n; i++) {
            for (Integer k : grafo.adjList.get(i)) {
                adyacencia[i][k] = 1;
                adyacencia[k][i] = 1;
            }
        }

        // comparar los vecinos
        for (int i = 0; i < v1.size(); i++) {
            for (int k = 0; k < v2.size(); k++) {
                if (adyacencia[v1.get(i)][v2.get(k)] == 0) {
                    return false;
                }
            }
        }
        return true;
    }

    // metodo que imprimi el resultado esperado para el programa
    public void determinarBiparticion(grafo grafo) {
        res r = isBipartito(grafo);
        if (r.respuesta == true) {
            System.out.println("\ngrafo is bipartite");

            System.out.println("V1: ");
            for (int i = 0; i < r.color.length; i++) {
                if (r.color[i] == true) {
                    System.out.print(i + "  ");
                }
            }
            System.out.println("\nV2: ");
            for (int i = 0; i < r.color.length; i++) {
                if (r.color[i] == false) {
                    System.out.print(i + "  ");
                }
            }
            System.out.println("\nCompleto: " + esCompleto(grafo, r.color));

        } else {
            System.out.println("\ngrafo is not bipartite");
        }
    }

    public static void main(String[] args) {
        // número total de nodos en el grafo (0 a 9)
        int n = 6;
        // Lista de bordes del grafo
        List<Edge> edges = Arrays.asList(
                new Edge(0, 3), new Edge(1, 3), new Edge(2, 3),
                new Edge(0, 4), new Edge(1, 4), new Edge(2, 4),
                new Edge(0, 5), new Edge(1, 5), new Edge(2, 5));
        // GRAFO COMPLETO Y BIPARTITO
        App app = new App();

        // construye un grafo a partir de los bordes dados
        grafo grafo = new grafo(edges, n);
        app.determinarBiparticion(grafo);
    }
}
