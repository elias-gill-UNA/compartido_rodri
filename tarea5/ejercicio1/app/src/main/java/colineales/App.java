/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package colineales;

public class App {

    public class punto {
        int x;
        int y;

        public punto(int x, int y) {
            this.y = y;
            this.x = x;
        }
    }

    public punto[] valoresPrueba() {
        punto[] res = { new punto(2, 3), new punto(1, 2), new punto(3, 4), new punto(4, 5), new punto(5, 6) };
        return res;
    }

    public static punto[][] getAllPosibilities(punto valores[]) {
        int v = (int) Math.pow(2, valores.length);
        punto aux[][] = new punto[v][valores.length];
        int intercalar = (int) Math.pow(2, valores.length);

        // Para hallar las combinaciones posibles, cargamos los valores como si se
        // tratase de una tabla de verdad
        for (int columna = 0; columna < (valores.length); columna++) {
            intercalar = intercalar / 2;
            boolean state = true;

            int counter = 1;
            for (int fila = 0; fila < (v); fila++) {
                // cargamos el valor si state == true
                if (state) {
                    aux[fila][columna] = valores[columna];
                } else {
                    aux[fila][columna] = null;
                }

                // realizamos el cambio de estado
                counter++;
                if (counter > intercalar) {
                    counter = 1;
                    state = !state;
                }
            }
        }
        return aux;
    }

    public static boolean sonColineales(punto valores[]) {
        // buscar y contar aquellos elementos del array de combinatoria que no son nulos
        int cont = 0;
        for (punto var : valores) {
            if (var != null) {
                cont++;
            }
        }

        // si no son 4 puntos no hagas nada
        if (cont < 4) {
            return false;
        }

        // crear un arreglo auxiliar con los puntos que no son nulos
        punto aux[] = new punto[cont];
        int i = 0;
        for (punto var : valores) {
            if (var != null) {
                aux[i] = var;
                i++;
            }
        }

        // calcular las pendientes una a una
        int pendiente = (aux[0].y - aux[1].y) / (aux[0].x - aux[1].x);
        for (i = 1; i < cont - 1; i++) {
            if (pendiente != (aux[i].y - aux[i + 1].y) / (aux[i].x - aux[i + 1].x)) {
                return false;
            }
        }

        return true;
    }

    // funcion que recibe un arreglo de puntos
    static public void programa(punto valores[]) {
        // obtener todas las combinaciones posibles del arreglo de puntos
        punto posibilidades[][] = getAllPosibilities(valores);
        int v = (int) Math.pow(2, valores.length);
        System.out.println("Las combinaciones de puntos colineales son:");

        // imprimir el resultado
        for (int i = 0; i < (v); i++) {
            if (sonColineales(posibilidades[i])) {
                for (int k = 0; k < (valores.length); k++) {
                    if (posibilidades[i][k] != null) {
                        System.out.print("(" + posibilidades[i][k].x + "," + posibilidades[i][k].y + ") ");
                    }
                }
                System.out.println();
            }
        }
    }

    // main
    public static void main(String[] args) {
        // generar nuevos valores de prueba
        App foo = new App();
        punto aux[] = foo.valoresPrueba();

        programa(aux);
    }
}
